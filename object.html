<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Object</title>
</head>
<body>
    <script>
        // 1. Literals and properties
        const name ='song'; //이렇게 변수를 선언해주고!
        const age = 4;
        pring(name, age); //이름과 나이를 각각 파라미터로 전달해 줘야함
        function pring(name, age)//함수를 정의해서 쓸 때도 이렇게 두가지 파라미터로 정의해야함.
            console.log(name); 
            console.log(age)
            //이렇게하면 문제가 주소나 full name, last name 등의 길어지는 것들에대해서 
            //추가해야하는 것들이 많아져 관리X  이것들을 개선하고자 object를 쓰는것임.

        //오브젝트를 만드는 방법
        const obj1 = {}; //'object literal' syntax 
        const obj2 = new Object(); // 'object constructor' syntax new 키워드사용


    function print(persong){
        console.log(person.name);
        console.log(person.age);
    }

    const song = {name: 'song', age: 4}; //괄호를 이용해서 object생성
    pring(song);

    song.hasjab = true //이렇게 뒤늦게 property를 추가할 수도 있음! 하지만 이것은
    //나중에 유지보수하기가 힘들고 생각지도 못한 에러가 발생! 가능하면 피해서 하는게 좋음 ㅎㅎ 
   // object = {key : value}의 집합체이다. key는 우리가 접근할 수 있는 property 그 값은 value


   //2. Computed properties 계산된 프로퍼티
   console.log(song.name); // object안의 데이터는 .을 이용해서 접근!
   console.log(song['name']); // []괄호를 이용해 string type으로 접근가능.
   //*key sould be always string
   song['hasjob'] = true;
   console.log(song.hasjob);
   //그럼 어떤 방법을 언제 쓰면 좋을까?
    console.log(song.name); //. 은 코딩하는 순간 그 키에 해당하는 값을 받아오고싶을때!
    console.log(song['name']);// computed properies는 정확하게 어떤 키가 필요한지 모를때! run time에서 결정될 때/실시간으로 원하는 값을 받아오고 싶을 때!
       
       //예를들어 
       function printValue(obj, key){ //원하는 key가 사용자에게 함수를 받아서 출력해야 하는 경우
           console.log(obj[key])
       }
       printValue(song, 'song');

    //3. Property value shorthand 
    const person1 = {name: 'bob', age: 2};
    const person2 = {name: 'steve', age: 3};
    const person3 = {name: 'dave', age: 4};
     //다른 사람을 추가하고 싶다면? (편하게)
    const person4 = makePerson('song', 30); //4번을 만들어주면?
       console.log(person4);


    function makePerson(name, age) { //makePerson을 만들어줘서 name,age를 할당해주고
        return{
            name,
            age, //name과 age값을 넣어준다!그리고 위로 가서 4번 person 생성
        }; 
    };
    //**위와 아래 연결

     //해결해고자 하던것? = 추가 시 반복되는 것 없애기
     // object를 필요할 때마다 추가할 경우, 값만 전달해주면 object를 전달해주는 것을 만들기!
    //makePerson = class와 같은 아이!
    // 값을 받는것이 아닌 순수하게 object를 생성시에는 Person처럼 대문자사용
    // 값x  this.name = name; this.age = age;
    // 호출시에도 const person4 = new Person('song', 30); 이런식으로 작성하면 알아서 object 생성
    // 여기서 생략된것은!! 

    // 4. Constructor function
    function Person(name, age){
        this = {};
        this.name = name;
        this.age = age;
          return this;
    }


    //5. in operator: property existence check (key in obj)해당하는 object안에 key가 있는지 없는지 확인해줌!
    console.log('name' in song); //=true
    console.log('age' in song); //=true
    console.log('random' in song); //=false
    console.log(song.random); //=undefined

    //6. for..in vs for..of 
    //for (key in obj)
    for (key in song) {//song이 가지고 있는 key들이 한번씩 돌 때마다 지역변수에 할당이 되어짐
        console.log(key);
    }
    //console.clear(); 앞에 키들이 지워짐!

    //for(value of iterable)
    const array = [1, 2, 4, 5];
    for(let i = 0; i < array.length ; i++){
        console.log(array[i])
    }//옛날에 했던 긴..방법...더 쉽게하려면!!

    for(value of array) {
        console.log(value);
    }


    //7. clonin (Object.assign(dest, [obj1, obj2, obj3])
    const user = {name: 'song', age: '20'}; 
    const user2 = user; //user와 동일한 레퍼런스가 들어있음! 만약에
    user2.name = 'coder';
    console.log(user); // name은 coder로 변경되어 나옴!

    //object를 복사하는방법이 있나요?
    //old way 
    const user3 = {} //빈 object 생성
    for(key in user) {
        user3[key] = user[key];
    } //수동적으로 빙글빙글 돌면서 할당해주었음.
    console.log(user3);
    //첫번째 돌 때는 key는 name, 두번째는 age가 됨. manual적 
    
    //new way
    const user4 = {};
    Objedct.assign(user4, user);
    //복사하고자하는 타겟과 소스를 함께 전달해 주어야함. 
    console.log(user4);


    //another example
    const fruit1 = {color: 'red'};
    const fruit2 = {color: 'blue', size: 'big'}; //fruit의 공통은 color! size라는 새로운 property가 2에 들어감.
    const mixed = Object.assign({}, fruit1, fruit2); //color,size를 섞은게 mixed
    console.log(mixed.color);
    console.log(mixed.size); //무엇이 출력될까? 
    // blue와 big이 출력됨! 왜냐? 뒤에 새 값이 있으면 덮어 씌워짐!
     

       
       
       </script>
</body>
</html>